var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import { BaseCollection, EdgeCollection, Types, isArangoCollection } from "./collection";
export class GraphVertexCollection extends BaseCollection {
    constructor(connection, name, graph) {
        super(connection, name);
        this.type = Types.DOCUMENT_COLLECTION;
        this.graph = graph;
        this._gharial = this._api.route(`/gharial/${this.graph.name}/vertex`);
    }
    _documentPath(documentHandle) {
        return `/document/${this._documentHandle(documentHandle)}`;
    }
    vertex(documentHandle) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.get(`/${this._documentHandle(documentHandle)}`);
            return res.body.vertex;
        });
    }
    save(data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.post(this.name, data, opts);
            return res.body.vertex;
        });
    }
    replace(documentHandle, newValue, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (typeof opts === "string") {
                opts = { rev: opts };
            }
            if (opts.rev) {
                let rev;
                ({ rev } = opts, opts = __rest(opts, ["rev"]));
                headers["if-match"] = rev;
            }
            const res = yield this._gharial.put(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
            return res.body.vertex;
        });
    }
    update(documentHandle, newValue, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (typeof opts === "string") {
                opts = { rev: opts };
            }
            if (opts.rev) {
                let rev;
                ({ rev } = opts, opts = __rest(opts, ["rev"]));
                headers["if-match"] = rev;
            }
            const res = yield this._gharial.patch(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
            return res.body.vertex;
        });
    }
    remove(documentHandle, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (typeof opts === "string") {
                opts = { rev: opts };
            }
            if (opts.rev) {
                let rev;
                ({ rev } = opts, opts = __rest(opts, ["rev"]));
                headers["if-match"] = rev;
            }
            const res = yield this._gharial.delete(`/${this._documentHandle(documentHandle)}`, opts, headers);
            return res.body.removed;
        });
    }
}
export class GraphEdgeCollection extends EdgeCollection {
    constructor(connection, name, graph) {
        super(connection, name);
        this.type = Types.EDGE_COLLECTION;
        this.type = Types.EDGE_COLLECTION;
        this.graph = graph;
        this._gharial = this._api.route(`/gharial/${this.graph.name}/edge`);
    }
    edge(documentHandle) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.get(`/${this._documentHandle(documentHandle)}`);
            return res.body.graph;
        });
    }
    save(data, fromId, toId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fromId !== undefined) {
                if (toId !== undefined) {
                    data._from = this._documentHandle(fromId);
                    data._to = this._documentHandle(toId);
                }
                else {
                    opts = fromId;
                }
            }
            const res = yield this._gharial.post(this.name, data, opts);
            return res.body.edge;
        });
    }
    replace(documentHandle, newValue, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (typeof opts === "string") {
                opts = { rev: opts };
            }
            if (opts.rev) {
                let rev;
                ({ rev } = opts, opts = __rest(opts, ["rev"]));
                headers["if-match"] = rev;
            }
            const res = yield this._gharial.put(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
            return res.body.edge;
        });
    }
    update(documentHandle, newValue, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (typeof opts === "string") {
                opts = { rev: opts };
            }
            if (opts.rev) {
                let rev;
                ({ rev } = opts, opts = __rest(opts, ["rev"]));
                headers["if-match"] = rev;
            }
            const res = yield this._gharial.patch(`/${this._documentHandle(documentHandle)}`, newValue, opts, headers);
            return res.body.edge;
        });
    }
    remove(documentHandle, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {};
            if (typeof opts === "string") {
                opts = { rev: opts };
            }
            if (opts.rev) {
                let rev;
                ({ rev } = opts, opts = __rest(opts, ["rev"]));
                headers["if-match"] = rev;
            }
            const res = yield this._gharial.delete(`/${this._documentHandle(documentHandle)}`, opts, headers);
            return res.body.removed;
        });
    }
}
export class Graph {
    constructor(connection, name) {
        this.name = name;
        this._connection = connection;
        this._api = this._connection.route("/_api");
        this._gharial = this._api.route(`/gharial/${this.name}`);
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.get();
            return res.body.graph;
        });
    }
    create(properties = {}, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._api.post("/gharial", Object.assign({}, properties, { name: this.name }), opts);
            return res.body.graph;
        });
    }
    drop(dropCollections = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.delete({ dropCollections });
            return res.body.removed;
        });
    }
    vertexCollection(collectionName) {
        return new GraphVertexCollection(this._connection, collectionName, this);
    }
    listVertexCollections(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.get("/vertex", opts);
            return res.body.collections;
        });
    }
    vertexCollections(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const names = yield this.listVertexCollections(opts);
            return names.map((name) => new GraphVertexCollection(this._connection, name, this));
        });
    }
    addVertexCollection(collection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isArangoCollection(collection)) {
                collection = collection.name;
            }
            const res = yield this._gharial.post("/vertex", {
                collection
            });
            return res.body.graph;
        });
    }
    removeVertexCollection(collection, dropCollection = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isArangoCollection(collection)) {
                collection = collection.name;
            }
            const res = yield this._gharial.delete(`/vertex/${collection}`, {
                dropCollection
            });
            return res.body.graph;
        });
    }
    edgeCollection(collectionName) {
        return new GraphEdgeCollection(this._connection, collectionName, this);
    }
    listEdgeCollections() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.get("/edge");
            return res.body.collections;
        });
    }
    edgeCollections() {
        return __awaiter(this, void 0, void 0, function* () {
            const names = yield this.listEdgeCollections();
            return names.map((name) => new GraphEdgeCollection(this._connection, name, this));
        });
    }
    addEdgeDefinition(definition) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.post("/edge", definition);
            return res.body.graph;
        });
    }
    replaceEdgeDefinition(definitionName, definition) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.put(`/edge/${definitionName}`, definition);
            return res.body.graph;
        });
    }
    removeEdgeDefinition(definitionName, dropCollection = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._gharial.delete(`edge/${definitionName}`, {
                dropCollection
            });
            return res.body.graph;
        });
    }
    traversal(startVertex, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._api.post("/traversal", Object.assign({}, opts, { startVertex, graphName: this.name }));
            return res.body.result;
        });
    }
}
//# sourceMappingURL=graph.js.map