import { format as formatUrl, parse as parseUrl } from "url";
import { joinPath } from "./joinPath";
import xhr from "./xhr";
export const isBrowser = true;
function omit(obj, keys) {
    const result = {};
    for (const key of Object.keys(obj)) {
        if (keys.includes(key))
            continue;
        result[key] = obj[key];
    }
    return result;
}
export function createRequest(baseUrl, agentOptions) {
    const baseUrlParts = parseUrl(baseUrl);
    const options = omit(agentOptions, [
        "keepAlive",
        "keepAliveMsecs",
        "maxSockets"
    ]);
    return function request({ method, url, headers, body, expectBinary }, cb) {
        const urlParts = Object.assign({}, baseUrlParts, { pathname: url.pathname
                ? baseUrlParts.pathname
                    ? joinPath(baseUrlParts.pathname, url.pathname)
                    : url.pathname
                : baseUrlParts.pathname, search: url.search
                ? baseUrlParts.search
                    ? `${baseUrlParts.search}&${url.search.slice(1)}`
                    : url.search
                : baseUrlParts.search });
        let callback = (err, res) => {
            callback = () => undefined;
            cb(err, res);
        };
        const req = xhr(Object.assign({ responseType: expectBinary ? "blob" : "text" }, options, { url: formatUrl(urlParts), withCredentials: true, useXDR: true, body,
            method,
            headers }), (err, res) => {
            if (!err)
                callback(null, res);
            else {
                const error = err;
                error.request = req;
                callback(error);
            }
        });
    };
}
//# sourceMappingURL=request.web.js.map